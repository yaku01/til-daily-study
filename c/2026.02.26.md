챕터 1-3 : Compiler (1)
### 컴파일과 빌드

컴파일은 두 가지 의미를 가지고 있습니다. 상황에 따라 적절하게 두 가지 의미 중 하나를 생각하면 됩니다.

 1️⃣

확장된 소스코드가 어셈블리 코드로 변환되는 과정.

2️⃣

소스코드부터 오브젝트 코드까지의 과정.



📌

**빌드(Build)**

빌드는 아래 그림 전체 과정을 빌드라고 부릅니다. 빌드 == (컴파일 + 링킹).

<img width="1363" height="535" alt="image" src="https://github.com/user-attachments/assets/6fcff5f7-6047-44d7-a1d8-10f8218c7884" />

### 컴파일러

컴파일러도 컴파일과 똑같이 두 가지 의미를 가지고 있습니다.

 1️⃣

확장된 소스코드를 어셈블리 코드로 변환해주는 프로그램.



 2️⃣

소스코드로 실행파일까지 만들어 주는 프로그램.

대부분의 경우엔 2번을 의미합니다. 우리도 2번 의미의 컴파일러를 다운 받아서 실습 환경 구축해보겠습니다.

### 솔루션 - 프로젝트 - 소스코드

소스코드를 작성하려면 비주얼 스튜디오를 켜고 솔루션이라는 것을 먼저 만들어야 합니다.
솔루션 안에는 프로젝트라는 것이 들어있고, 이 프로젝트 안에 소스코드가 들어있습니다.

<img width="757" height="477" alt="image" src="https://github.com/user-attachments/assets/9b97876b-a6bd-4e8c-9495-fbd692061c9f" />

###Ex010301) 새 솔루션 만들기

###Ex010302) 비주얼 스튜디오 소스코드 에디터 레이아웃

###Ex010303) 비주얼 스튜디오 소스코드 에디터 살펴보기


________________________________________________________________________________________________________________________________________________________________________

챕터 1-4 : 프로젝트와 소스코드 생성 (1)

###Ex010401) 이전 작업 여는 방법

###Ex010402) 새 프로젝트 추가하는 방법

### 시작 프로젝트

소스코드 에디터를 빌드하면 하나의 프로젝트만 시작 프로젝트로 설정하고 빌드 할 수 있습니다.
같은 하늘 아래 두 태양이 없듯, 시작 프로젝트는 하나.

###Ex010403) 시작 프로젝트 설정하는 방법

###Ex010404) 소스코드(명령서) 삭제하기

###Ex010406) 백지부터 시작해보자.

### 빌드하는 방법

**F5**

현재 시작 프로젝트의 소스코드가 빌드 및 실행됩니다.

가장 많이 쓰이는 단축키입니다.

**Ctrl + B**

빌드만 수행됩니다.

###Ex010407) Error List와 Output 보는 방법

________________________________________________________________________________________________________________________________________________________________________

챕터 1-5 : main() 함수와 printf() 함수 (1)

### 프로그램의 시작점(Entry Point)

main() 함수는 프로그램의 시작점입니다.
즉, 모든 프로그램에게는 main() 함수가 있어야 합니다.

앞으로 Ex010501 같이 예제가 나오면 새 프로젝트를 만들어서 실습하면 됩니다.
// Main.c

int main(void)
{


	return 0;
}
<img width="1107" height="619" alt="image" src="https://github.com/user-attachments/assets/7e2ea74b-086f-47c3-a44d-3d49689319e5" />


### 예제코드 설명

```cpp
// Main.c

int main(void)  // main() 함수의 시작.
{

	return 0;     // main() 함수의 종료이자, 한 줄의 명령어 종료(세미콜론).
}

```

두 가지 좋은 습관

코드 작성에서 가장 중요한 것은 “시작이 있으면 무조건 끝을 맺어줘야 한다.”입니다.
만약 열었다면 무조건 닫는 문법이 있고, 소유 했다면 다시 돌려주는 문법이 있습니다.
다시 말하지만, 컴퓨터는 사람이 아닙니다. 유추라는 능력이 없습니다.
당연히 컴퓨터는 어디가 시작이고 어디가 끝인지 알 수 없습니다.

2️⃣

들여 쓰기를 생활화 합시다.
들여 쓰기를 처음부터 안하면 끝까지 안하는게 습관처럼 됩니다.
악필이 습관 되는 것입니다.

### 콘솔 화면에 글자를 출력해보고 싶다면?

지금까지는 아무런 내용이 없는 빈 백지부터,
프로그램의 시작점인 main() 함수까지 작성해보았습니다.
이번에는 콘솔 화면에 글자를 띄워보고 싶다면 어떻게 해야할까요?
### 예제코드 설명

```cpp
// Main.c

#include <stdio.h>         // stdio는 공구통 이름. #include는 공구통을 포함시키라는 명령어.

int main(void)
{
	printf("Hello, world!"); // stdio라는 공구통 안에 든 printf()라는 망치를 사용하는 예시.

	return 0;
}

```
### printf() 함수

print formatted의 약자입니다. “양식에 맞게 출력하다”라는 뜻입니다.
그래서 탈출 문자열 혹은 서식 지정자와 함께 쓰입니다.

### 탈출 문자열(Escape Sequence)

탈출 문자 ’\’와 함께 작성된 문자열.
C언어에서 문자열은 시작 큰 따옴표와 끝 큰 따옴표로 감싸져 있습니다.
이 문자열 도중에 다른 의미를 가지는 문자열을 넣어서 사용합니다. 즉, 잠시 문자열을 “탈출”합니다.
	출력
\n	개행(New line)
\t	탭(Tap)
\’	따옴표 출력
\”	쌍따옴표 출력
\\	역슬래시 출력
%%	% 출력

### Ex010503**)** 개행하기

```cpp
// Main.c

#include <stdio.h>

int main(void)
{
	printf("Hello\nworld!");

	return 0;
}

```
```
### Ex010504**)** 탈출 문자열

```cpp
// Main.c

#include <stdio.h>

int main(void)
{
    printf("She said, \"We alright!\"\n");
    printf("And I thought, \'Um, that's not a big deal.\'\n");
    printf("Our 1/4 quater profit rose by 10%% and earned \\1,000,000,000\n");
    printf("..\\Desktop\\C\\Section01\\printf()\n");

	return 0;
}

```
________________________________________________________________________________________________________________________________________________________________________

챕터 1-6 : 서식지정자
### 서식 지정자(Format Specifier)

printf() 함수 혹은 scanf() 함수와 같은 입출력 함수들과 함께 쓰여서
양식에 맞게 입출력 할 수 있게끔 도와주는 지정자.
문자열의 원하는 위치에 서식 지정자를 넣어서 사용합니다.

### 서식 지정자의 종류

<aside>
1️⃣**%d**: decimal의 약자. 10진수로 대체됩니다.

2️⃣**%o**: octal의 약자. 8진수로 대체됩니다. ex) 9(10) <-> 11(8)

3️⃣**%x**: hexadecimal의 약자. x는 소문자, X는 대문자로 대체됩니다. ex) 17(10) <-> 11(16)

4️⃣**%u**: unsigned의 약자. 양수로 대체됩니다.

5️⃣**%c**: character의 약자. 문자로 대체됩니다.

6️⃣**%s**: string의 약자. 문자열로 대체됩니다.

7️⃣**%f**: floating point의 약자. single precision.  

8️⃣**%lf**: double precision floating point.

### 서식 지정자는 왜 필요할까요?

3245라는 숫자를 문자열에 편입시키기 위해서 printf(“Result: %d”, 3245)라고 적을 수 있습니다.
또한 서식 지정자를 활용하면 계산 결과도 얻어 낼 수 있습니다.
3245 * 2342의 계산 결과를 화면에 출력시키기 위해 
printf(”Result: %d”, 3245 * 2342)라고도 적을 수 있습니다.
즉, 복잡한 수식을 빠른 시간안에 계산하고 그 결과를 원하는 형식으로 보기 위함입니다.
복잡한 소스코드를 작성할 때 디버깅 용도로 요긴하게 사용되기도 합니다.

### Ex010601**)** 서식시정자

```c
#include <stdio.h>

int main(void)
{
    printf("%d", 3245 * 2342);
    printf("%f", 3245 * 2342);

    return 0;
}
```
### printf() 함수 코드를 정확하고 쉽게 이해하는 방법

뒤에서부터 해석하면 훨씬 쉬워집니다. 결국 영어로 작성하기에, 어순이 우리나라와 다릅니다.
printf(”%d”, 3245 * 2342); 라는 코드는 “3245 * 2342를 %d 형식으로 printf해라”라고 해석합니다.
후에 배울 scanf()도 동일하게 뒤에서부터 해석하는게 편합니다.

### Ex010602**)** 정수 서식지정자

```c
#include <stdio.h>

int main(void)
{
    printf("[%d]\n", 65536);
    printf("[%2d]\n", 65536);
    printf("[%5d]\n", 65536);
    printf("[%7d]\n", 65536);
    printf("[%-7d]\n", 65536);
    printf("[%07d]\n", 65536);
    printf("[%+7d]\n", 65536);

    return 0;
}
```

### Ex010603**)** 실수 서식지정자

```c
#include <stdio.h>

int main(void)
{
    printf("[%f]\n", 3.141592);
    printf("[%.2f]\n", 3.141592);
    printf("[%.10f]\n", 3.141592);
    printf("[%5.2f]\n", 3.141592);
    printf("[%5.10f]\n", 3.141592);
    printf("[%+20.10f]\n", 3.141592);
    printf("[%-20.10f]\n", 3.141592);

    return 0;
}
```
________________________________________________________________________________________________________________________________________________________________________
챕터 1-7 : 리터럴
### 리터럴(Literal)

소스코드에 적힌 값 그 자체를 뜻합니다.
앞으로 저자가 “값”이라고 칭하는 것들은 “리터럴”의 의미를 지닌다고 생각하면 됩니다.

### Ex010701**)** 리터럴

```c
// Main.c

#include <stdio.h>

int main(void)
{
    65536;           // 정수 리터럴. 
    65536LL;         // 정수 리터럴. 
    65536u;          // 정수 리터럴. 
    3.141592;        // 실수 리터럴.
    3.141592f;       // 실수 리터럴.
    'd';             // 문자 리터럴. ''는 문자 리터럴 기호.
    "Hello, world!"; // 문자열 리터럴. ""는 문자열 리터럴 기호.

    return 0;
}
```

### 예제 Ex010701은 경고가 뜬다.

경고(Warning)는 에러(Error)와 다릅니다.
에러가 뜨면 빌드 실패되지만, 경고는 빌드 시켜줍니다.
다만, 경고도 되도록 모두 잡고 가는 것이 국룰입니다.


### Ex010702) 리터럴 출력

```cpp
// Main.c

#include <stdio.h>

int main(void)
{
    printf("%d + %d = %d\n", 54232, 36629, 54232 + 36629);
    printf("%d\n", 14);
    printf("%o\n", 016);
    printf("%x\n", 0xe);
    printf("%X\n", 0XE);
    printf("%c\n", 'd');
    printf("%s\n", "Hello, world!");

    printf("%f", 3.141592f);

    return 0;
}

________________________________________________________________________________________________________________________________________________________________________
챕터 1-8 : 자료형



### 자료형의 필요성

컴퓨터는 아주 단순히 말해서, 계산하고 저장하는 기계.
우리가 입력한 모든 값은 결국 0과 1로 저장됩니다.
하지만 컴퓨터는 그 0과 1의 묶음들이 무엇을 의미하는지 전혀 알 수 없습니다.
어디서부터 어디까지(크기)를 어떻게 해석해야하는지 알려줘야합니다.
이 역할을 하는 것이 자료형입니다.


### 컴퓨터 공학에서의 크기 단위

컴퓨터 공학에서 가장 작은 크기 단위는 1 bit입니다.
이진법의 한 자리에 해당하는 크기입니다.

컴퓨터 상식적으로 8 bits를 1 byte라고 부릅니다.

다시 1024 bytes를 1 mb라고 부릅니다.

### 자료형(Type)

저장될 데이터의 크기와 해석 방법에 대한 정보.
자료형	크기 == 표현 가능한 수	서식 지정자
char	1 byte. -(2^7) ~ (2^7) - 1
[-128 ~ 127]	%c or %hhd
short int	2 byte. -(2^15) ~ (2^15) - 1
[-32768 ~ 32767]	%hd
int
[기본 정수 자료형]	4 byte. -(2^31) ~ (2^31) - 1
[-2147483648 ~ 2147483647]	%d or %i
long	4 byte or 8 byte.	%ld
long long	8 byte. -(2^63) ~ (2^63) - 1	%lld
float	4 byte. 유효 자리수 6~7자리.
[부호: 1bit, 지수: 8bit, 가수: 23bit]	%f
double
[기본 실수 자료형]	8 byte. 유효 자리수 15~16자리.
[부호: 1bit, 지수: 11bit, 가수: 52bit]	%lf
long double	8 byte 이상.	%Lf

### Ex010801**)** 리터럴과 자료형

주석 내용도 모두 따라서 적어야합니다.

```c
#include <stdio.h>

int main(void)
{
    65536;           // int 자료형의 리터럴. 즉, int는 "기본 정수 자료형".
    65536LL;         // LL은 long long의 약자. 즉, long long 자료형의 리터럴 기호. l은 1과 헷갈리기 때문에 잘 안씁니다.
    65536u;          // u는 unsigned의 약자. unsigned의 리터럴 기호.
    3.141592;        // double 자료형의 리터럴. 즉, double은 "기본 실수 자료형".
    3.141592f;       // float 자료형의 리터럴 기호 f.
    'd';             // char 자료형의 리터럴. ''는 char 자료형의 리터럴 기호.
    "Hello, world!"; // 문자열 리터럴. ""는 문자열 리터럴 기호. const char[] 자료형 리터럴 기호.

    return 0;
}
```
________________________________________________________________________________________________________________________________________________________________________
챕터 1-9 : 변수
### 변수(Variable) <-> 상수(Constant) [중요 샘플 코드]

변할 수 있는 수. 아래와 같은 형식으로 선언하게 됩니다.

```cpp
자료형 변수명 = 값;
```

.### Ex010901) 자료형 변수명 = 값; [중요 샘플 코드]

```c
// Main.c

#include <stdio.h>

int main(void)
{
	// 자료형 변수명 = 값;
	int Num = 2147483647; // 선언과 동시에 초기화
	double PI;            // 선언

	printf("Num = %d\n", Num);

	PI = 3.141592;
	printf("PI = %lf\n", PI);

	return 0;
}
```

### unsigned 키워드와 signed 키워드

부호 없는 Vs. 부호 있는.
unsigned를 자료형 앞에 붙히면 음수는 표현 불가능. 대신 양수 부분이 2배 늘어납니다.
서식 지정자로는 %u를 쓰면 됩니다.
모든 자료형은 사실 앞에 signed 키워드가 생략되어 있습니다.

아래와 같은 코드를 작성 후 실행 결과 예측하고 실행해서 확인해봅시다.

Ex010902) 오버플로우
```c

// Main.c

#include <stdio.h>

int main(void)
{
	char CharNum = -128;
	signed char SignedCharNum = -128;
	unsigned char UnsignedCharNum = 255;
	unsigned char UnsignedCharNumWithOverflow = -1;

	short ShortNum = -32768;
	signed short SignedShortNum = -32768;
	unsigned short UnsignedShortNum = 65535;
	unsigned short UnsignedShortNumWithOverflow = -1;

	printf("CharNum: %hhd\n", CharNum);
	printf("SignedCharNum: %hhd\n", SignedCharNum);
	printf("UnsignedCharNum: %hhu\n", UnsignedCharNum);
	printf("UnsignedCharNumWithOverflow: %hhu\n", UnsignedCharNumWithOverflow);

	printf("ShortNum: %hd\n", ShortNum);
	printf("SignedShortNum: %hd\n", SignedShortNum);
	printf("UnsignedShortNum: %hu\n", UnsignedShortNum);
	printf("UnsignedShortNumWithOverflow: %hu\n", UnsignedShortNumWithOverflow);

	return 0;
}
```
### 오버플로우(Overflow)

자료형이 표현 가능한 수를 넘어서는 경우.
그릇에 물을 너무 많이 따르면 넘쳐 흐르는 것과 같습니다.

- 도식화

<img width="741" height="881" alt="image" src="https://github.com/user-attachments/assets/eee89d9c-edd7-443b-8e51-6784f23eeea7" />


N은 각 자료형의 크기. char는 8, int는 32를 대입.

<img width="673" height="875" alt="image" src="https://github.com/user-attachments/assets/bd05f207-f055-410b-9469-8146e44d2fc8" />


char 자료형의 오버플로우 도식화.

________________________________________________________________________________________________________________________________________________________________________
챕터 1-10 : ASCII

### 컴퓨터는 문자를 이해할 수 없음.

누군가는 “어, char 자료형의 변수에 문자 저장 가능한데요?” 라고 반문할 수 있습니다. Nope!!!
프로그래머는 문자로 작성된 소스코드를 컴퓨터가 그대로 이해할 수 없기에
컴파일러를 통해 이진패턴으로 만들었다는 걸 기억해야 합니다. 이 과정을 빌드 프로세스라고 불렀습니다.
즉, char 자료형의 변수에 문자를 그대로 저장할 수 없다는 뜻입니다. 뭔가 처리가 필요합니다.

### 인코딩(Encoding) Vs. 디코딩(Decoding)

형태 A에서 형태 B로 변환하는 것을 인코딩이라 합니다.
반대로 형태 B에서 형태 A로 변환하는 것을 디코딩이라 합니다.

### ASCII(American Standarded Code for Information Interchange)

문자 형태의 데이터와 숫자 형태의 데이터 사이의 인코딩 규약 중 하나.
여러 인코딩 규약이 있으나, 그 중 가장 쉽고 대표적인 규약.
규칙 표는 [[***여기***](https://en.cppreference.com/w/cpp/language/ascii)]를 참고하시면 됩니다.
어쨋든 컴퓨터에 값이 저장되기 위해서는 숫자 형태여야 한다는 점을 기억합시다.

### Ex011001**)** ASCII

아래와 같은 코드를 작성 후 실행 결과 예측하고 실행해서 확인해봅시다.

```c
// Main.c

#include <stdio.h>

int main(void)
{
	char ch1 = 'A';
	char ch2 = '1';

	printf("ch1 = %c\n", ch1);
	printf("ch1 = %d\n", ch1);
	printf("ch1 + 2 = %c\n", ch1 + 2);
	printf("ch1 + 2 = %d\n", ch1 + 2);

	printf("ch2 = %c\n", ch2);
	printf("ch2 = %d\n", ch2);
	printf("ch2 + 2 = %c\n", ch2 + 2);
	printf("ch2 + 2 = %d\n", ch2 + 2);

	printf("'A' + 24 = %c\n", 'A' + 24);
	printf("'A' + 24 = %d\n", 'A' + 24);

	return 0;
}
```
### [참고] 지역별 문자 인코딩과 유니코드

과거에는 ASCII, EUC-KR 등등 각 나라마다 다른 문자 인코딩들이 존재했습니다. 이는 서로 호환되지 않아 다국어 지원에 문제가 생겼습니다.

그래서 전세계 모든 문자를 표현 및 처리하기 위해 만들어진 문자 인코딩이 유니코드(Unicode)입니다.

유니코드에는 UTF-8, UTF-16, UTF-32가 있습니다.

________________________________________________________________________________________________________________________________________________________________________

챕터 2-1 : 연산자와 피연산자, 산술 연산자, 복합 대입 연산자, 값식문 (1)



### 사실 지금까지 연산자를 사용해왔습니다.

덧셈, 뺄셈, 곱셈, 나눗셈, …



### 연산자(Operator) Vs. 피연산자(Operand)

피연산자와 함께 사용되어서 계산 결과를 만들어 내는 기호.
ex) 5 + 2에서 5와 2를 피연산자, +를 연산자라고 합니다.



### 연산자 우선순위(Operator Priority)와 결합법칙

덧셈과 곱셈이 뒤섞여 있는 식에서 우리는 묵시적으로 곱셈을 먼저 계산합니다.
이처럼 연산자들 간에는 우선순위가 존재합니다.  ex) 3 + 5 * 2
만약 덧셈만 있는 식에서는 좌에서 우로 계산한다는 결합법칙도 있습니다. ex) 3 + 5 + 2

[[**여기**](https://learn.microsoft.com/en-us/cpp/c-language/precedence-and-order-of-evaluation?view=msvc-170#:~:text=precedence%20and%20associativity.-,Precedence%20and%20associativity%20of%20C%20operators,-Expand%20table)]에서 연산자 우선순위와 결합법칙 표를 볼 수 있습니다.


### 산술 연산자의 종류

덧셈, 뺄셈, 곱셈, 나눗셈, 나머지(%). 여기서 나머지 연산자가 어려울 수 있습니다.
나눗셈은 몫을 구하는 연산자이고, 나머지 연산자는 말그대로 나눗셈의 나머지를 구하는 연산자입니다.


### 정수 피연산자와 실수 피연산자

int 자료형끼리의 나눗셈은 그 결과도 int.
float 자료형끼리의 나눗셈은 그 결과도 float임에 주의하셔야 합니다.
또, C언어에서는 float 자료형의 나머지 연산은 불가능합니다.


### 복합 대입 연산자

산술 연산과 대입 연산이 함께 계산되는 연산자.
ex) 복합 대입 연산자 *=은 곱셈 연산 후 대입됩니다.

```cpp
mul *= 3; // 동작자체는 mul = mul * 3; 코드와 똑같습니다.
```

### **값**(Value), **식**(Expression), **문**(Statement)


**값**은 이전 시간에 언급한 리터럴과 같습니다.

ex) 2147483647, 3.141592, “Hello, World!”, …



**식**은 피연산자와 연산자로 이루어져서 값으로 귀결되는 것들.

ex) 3 + 5, 5.43 - 9.2, …


**문**은 컴퓨터가 수행할 명령어.


```cpp
int num = 5;    // 선언문.
if (7 == num)   // 조건문. 7 == num은 조건식.
```

🤔

### 은행에 가서 오늘 번 돈인 1만원을 입금하려 합니다.

아래와 같이 입금 함수를 작성해도될까요?

```c
float CurrentAccountBalance = 980000;

void Deposit(int InMoney)
{
	CurrentAccountBalance = CurrentAccountBalance  + InMoney;

	return 0;
}

Deposit(10000);
```


### Feed-back

아래와 같은 코드들을 피드백 코드라고 부릅니다.
상당히 중요한 개념입니다.

```c
int s = 0;
s = s + 10; // s += 10과 같습니다. 현재 변수 = 이전 변수값 + 10;
            // s = s + 10 뿐만아니라, s -= 10이나 s %= 10 같이 다른 사칙연산도 피드백 코드 가능합니다.
```

```c
int CurrentPlayerExp = 2147483646;

void Kill(int MonsterExp)
{
	CurrentPlayerExp = CurrentPlayerExp + MonsterExp;

	return 0;
}

```
